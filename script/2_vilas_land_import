#!/usr/bin/env ruby
require 'bamfcsv'

def tree_density_percent density
  return 0.0 if density == 255.0
  density / 100.0
end

def housing_density_percent density
  case density
  when 1..6 then (2 ** (density + 1)) / 128.0
  else 0.0
  end
end

def imperviousness_percent density
  return 0.0 if density == 255.0
  density / 100.0
end

puts 'Parsing CSV...'
rows = BAMFCSV.read("script/data/vilas_conserv_game_spatial_1_acre_inputs.csv")
puts '  CSV parsed!'.green

header = rows.shift
@col_numbers = {:row => header.index("ROW"),
                :col => header.index("COL"),
                :cover_class => header.index("LANDCOV2001"),
                :imperviousness => header.index("IMPERV%2001"),
                :devel_density => header.index("HDEN00"),
                :forest_density => header.index("CANOPY%2001")}
x_col = @col_numbers[:col]
y_col = @col_numbers[:row]
row_hash = rows.index_by { |row| "#{row[x_col]}:#{row[y_col]}" }

world_id = ARGV[0]
world = World.find(world_id)

puts 'Deleting existing Resource Tiles...'
# world.resource_tiles.delete_all
ResourceTile.delete_all world_id: world_id
puts '  Deleted!'.green

puts 'Capturing Megatile IDs...'
megatile_ids = world.megatiles.inject({}) do |memo, megatile|
  memo["#{megatile.x}:#{megatile.y}"] = megatile.id
  memo
end
puts '  IDs found!'.green

def row_to_hash row
  result = {}
  @col_numbers.each do |k, v|
    result[k] = row[v]
  end
  result
end

def developed_but_not_lived_in? tile_hash
  (tile_hash[:development_intensity] >= 0.5 || tile_hash[:imperviousness] >= 0.5) && tile_hash[:housing_density] <= 0.75
end

batch_size = 12000
r_count = 0
r_total = rows.count / batch_size
@start_time = Time.now

puts 'Starting Resource Tile Generation...'
rows.in_groups_of batch_size do |row_batch|
  tiles_to_import = []

  row_batch.each do |row|
    row_hash = row_to_hash(row)
    class_code = row_hash[:cover_class].to_i

    tile_x = row_hash[:row].to_i
    tile_y = row_hash[:col].to_i

    megatile_x = tile_x % world.megatile_width
    megatile_y = tile_y % world.megatile_height
    megatile_id = megatile_ids["#{megatile_x}:#{megatile_y}"]

    tile_class = LandTile
    tile_hash = { world_id: world_id,
                  megatile_id: megatile_id,
                  x: tile_x,
                  y: tile_y }

    tile_hash[:tree_density] = tree_density_percent(row_hash[:forest_density].to_f)
    tile_hash[:housing_density] = housing_density_percent(row_hash[:devel_density].to_f)
    tile_hash[:imperviousness] = imperviousness_percent(row_hash[:imperviousness].to_f)

    case class_code

    # Open Water, Emergent Herbaceous Wetlands
    when 11, 95 
      if tile_hash[:housing_density] > 0
        tile_hash[:zoned_use] = "Development"
        tile_hash[:primary_use] = "Housing"
      else
        tile_class = WaterTile
      end

    # Developed
    when 21..24 
      tile_hash[:zoned_use] = "Development"
      tile_hash[:development_intensity] = (class_code - 20.0 / 4.0)
      tile_hash[:primary_use] = developed_but_not_lived_in?(tile_hash) ? "Industry" : "Housing"

    # Barren land
    when 31
      # tile_hash[:zoned_use] = "Barren"

    # Forest, Scrub, Herbaceous, Wetlands
    when 41..71, 90
      tile_hash[:primary_use] = "Forest"
      tile_hash[:tree_species] = case class_code
                                 when 41 then ResourceTile.verbiage[:tree_species][:deciduous]
                                 when 42 then ResourceTile.verbiage[:tree_species][:coniferous]
                                 when 43 then ResourceTile.verbiage[:tree_species][:mixed]
                                 else ResourceTile.verbiage[:tree_species][:unknown]
                                 end
    # Farmland
    when 81..82
      tile_hash[:primary_use] = case class_code
                                when 81 then "Agriculture/Pasture"
                                when 82 then "Agriculture/Cultivated Crops"
                                end
      tile_hash[:zoned_use] = "Agriculture"

    # Off the end of the world, Water for now
    when 255 
      tile_class = WaterTile

    else
      raise "Unknown tile class code #{class_code}"
    end

    tiles_to_import << tile_class.new(tile_hash)
  end

  ResourceTile.import tiles_to_import, validate: false, timestamps: false

  r_count += 1
  puts "Resource tiles: %.2f%% (%.2f tiles/sec)".green.and_go_up(1) % [((r_count * 100.0) / r_total), (r_count * batch_size) / (Time.now - @start_time) ]
end
puts '  Generation finished!'.green
