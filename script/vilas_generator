#!/usr/bin/env ruby
require 'bamfcsv'

def tree_density_percent density
  return 0.0 if density == 255.0
  density / 100.0
end

def housing_density_percent density
  case density
  when 1..6 then (2 ** (density + 1)) / 128.0
  else 0.0
  end
end

def imperviousness_percent density
  return 0.0 if density == 255.0
  density / 100.0
end

def soil_amount amount
  return nil if amount == 255
  amount
end

puts 'Creating world...'
world = Factory :vilas
world_id = world.id
puts "  World created! '#{world.name}' ##{world_id}".green

puts "Spawning empty Megatiles..."
world.spawn_megatiles
puts "  Megatiles created!".green


puts 'Parsing CSV...'
rows = BAMFCSV.read("script/data/vilas_conserv_game_spatial_1_acre_inputs_combined.csv")
puts '  CSV parsed!'.green

header = rows.shift
@col_numbers = {:row => header.index("ROW"),
                :col => header.index("COL"),
                :cover_class => header.index("LANDCOV2001"),
                :imperviousness => header.index("IMPERV%2001"),
                :devel_density => header.index("HDEN00"),
                :forest_density => header.index("CANOPY%2001"),
                :frontage => header.index("FRONTAGE"),
                :lakesize => header.index("LAKESIZE"),
                :soil => header.index("SOIL")}
x_col = @col_numbers[:row]
y_col = @col_numbers[:col]
row_hash = rows.index_by { |row| "#{row[x_col]}:#{row[y_col]}" }

puts 'Deleting existing Resource Tiles...'
# world.resource_tiles.delete_all
ResourceTile.delete_all world_id: world_id
puts '  Deleted!'.green

puts 'Capturing Megatile IDs...'
megatile_ids = world.megatiles.inject({}) do |memo, megatile|
  memo["#{megatile.x}:#{megatile.y}"] = megatile.id
  memo
end
puts '  IDs found!'.green

def row_to_hash row
  result = {}
  @col_numbers.each do |k, v|
    result[k] = row[v]
  end
  result
end

def developed_but_not_lived_in? tile_hash
  (tile_hash[:development_intensity] >= 0.5 || tile_hash[:imperviousness] >= 0.5) && tile_hash[:housing_density] <= 0.75
end

batch_size = 2000
r_count = 0
r_total = rows.count / batch_size
@start_time = Time.now

puts 'Generating Resource Tiles...'
rows.each_slice(batch_size) do |row_batch|
  tiles_to_import = []

  row_batch.each do |row|
    row_hash = row_to_hash(row)
    class_code = row_hash[:cover_class].to_i

    tile_x = row_hash[:row].to_i
    tile_y = row_hash[:col].to_i

    megatile_x = tile_x % world.megatile_width
    megatile_y = tile_y % world.megatile_height
    megatile_id = megatile_ids["#{megatile_x}:#{megatile_y}"]

    tile_class = LandTile
    tile_hash = { world_id: world_id,
                  megatile_id: megatile_id,
                  x: tile_x,
                  y: tile_y }

    tile_hash[:tree_density] = tree_density_percent(row_hash[:forest_density].to_f)
    tile_hash[:housing_density] = housing_density_percent(row_hash[:devel_density].to_f)
    tile_hash[:imperviousness] = imperviousness_percent(row_hash[:imperviousness].to_f)
    tile_hash[:frontage] = row_hash[:frontage].to_f
    tile_hash[:lakesize] = row_hash[:lakesize].to_f
    tile_hash[:soil] = soil_amount(row_hash[:soil].to_i)

    case class_code

    # Open Water, Emergent Herbaceous Wetlands
    when 11, 95
      if tile_hash[:housing_density] > 0
        tile_hash[:zoned_use] = "Development"
        tile_hash[:primary_use] = "Housing"
      else
        tile_class = WaterTile
      end

    # Developed
    when 21..24
      tile_hash[:zoned_use] = "Development"
      tile_hash[:development_intensity] = (class_code - 20.0 / 4.0)
      tile_hash[:primary_use] = developed_but_not_lived_in?(tile_hash) ? "Industry" : "Housing"

    # Barren land
    when 31
      # tile_hash[:zoned_use] = "Barren"

    # Forest, Scrub, Herbaceous, Wetlands
    when 41..71, 90
      tile_hash[:primary_use] = "Forest"
      tile_hash[:tree_species] = case class_code
                                 when 41 then ResourceTile.verbiage[:tree_species][:deciduous]
                                 when 42 then ResourceTile.verbiage[:tree_species][:coniferous]
                                 when 43 then ResourceTile.verbiage[:tree_species][:mixed]
                                 else ResourceTile.verbiage[:tree_species][:unknown]
                                 end
    # Farmland
    when 81..82
      tile_hash[:primary_use] = case class_code
                                when 81 then "Agriculture/Pasture"
                                when 82 then "Agriculture/Cultivated Crops"
                                end
      tile_hash[:zoned_use] = "Agriculture"

    # Off the end of the world, Water for now
    when 255
      tile_class = WaterTile

    else
      raise "Unknown tile class code #{class_code}"
    end

    tiles_to_import << tile_class.new(tile_hash)
  end

  ResourceTile.import tiles_to_import, validate: false, timestamps: false

  r_count += 1
  r_percent = ((r_count * 100.0) / r_total)
  total_time = Time.now - @start_time
  tiles_per_sec = (r_count.to_f * batch_size) / total_time
  remaining_tiles = (r_total - r_count.to_f) * batch_size
  remaining_time = remaining_tiles / tiles_per_sec
  remaining_min, remaining_sec = remaining_time.divmod(60)
  puts "  Resource Tiles: %.2f%% (%.2f tiles/sec, ~%2d:%02d remaining)".green.and_go_up(1) % [r_percent, tiles_per_sec, remaining_min, remaining_sec]
end
puts '  Resource Tiles created!                                               '.green

puts "Creating Users and Players..."
[Lumberjack, Developer, Conserver].each_with_index do |player_klass, idx|
  user = Factory :user,
    name: "User #{world_id}-#{idx}",
    email: "u#{world.id}-#{idx}@example.com"
  player = player_klass.create :user => user, :world => world, :balance => 1000
  puts "  Player ##{player.id} (#{player_klass}) created!".green
end
